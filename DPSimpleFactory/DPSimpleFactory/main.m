//
//  main.m
//  DPSimpleFactory
//
//  Created by Johnson on 2018/8/22.
//  Copyright © 2018年 Johnson. All rights reserved.
//

#import <Foundation/Foundation.h>
#import "DPGenerator.h"

int main(int argc, const char * argv[]) {
    @autoreleasepool {
        DPMetaProduct *product = [DPGenerator createProduct:DPProductAType];
        [product showName];
    }
    return 0;
}
/*
 首先看一下简单工厂模式里各类都需要做什么，在工厂模式里我们定义了一个一方法，这个方法主要的职责是接收调用方的参数，然后相应的返回具体的产品。
 也就是说调用方不知具体返回的产品是什么样子，他只提供一个创建依据，具体创建何种产品，由工厂方式决定，这也就导致我们工厂类中返回的产品应该是一个被抽象过的父类，而调用方接收到的实际是具体的一个子类。
 这种模式的好处因该是显而易见的，轻量、调用简单，优点不想多说，只想说一下他的一个关键的缺点，进而引出下一节要讲的工厂模式。
 他的关键缺点就在于，当需求增加，也就是说我们增加产品的数量该怎么办，这时我们会自觉把焦点注意在工厂类中，因为我们发现关于产品的类只要增加一个新的产品类就好。而对于工厂类我们应该增加更多的判断去返回不同的产品。简单的例子当中只有一个判断依据，但需求复杂的话，我们可能还要在工厂类中掺杂一些业务上的逻辑，去准确的返回特定商品。
 随着产品的增加，我们的工厂类变得越来越难以维护，这也违反了一个设计原则**开放闭合原则**。
 简单点讲在这里有关于产品的类是符合开放封闭原则的，因为当增加产品我们不可能，也不应该在现在的这个产品结构中增加产品代码，有一点智商的都会去增加一个新的产品类，去迎合需求，开放封闭原则说的就是，当需求改变我们可以扩展结构，而不可以修改现有结构中的实体。（谁要是看到这里跟我杠 说如果是修改现有产品怎么办，那你自己想想是不是应该关掉这个网页了）。
 而工厂类则明显不遵循开放闭合原则，那聪明的你是不是想到了把工厂类变成和现在产品类相同的结构呢，这就是我们经常听到的工厂模式。
 */
