---
title: 设计模式-适配器模式
date: 2018-08-24 16:13:48
tags:
- "设计模式"
categories:
- "设计模式"
---

# 简述
适配器模式GOF总结如下
>将一个类的接口转换成客户希望的另外一个接口，适配器模式使得由于接口不兼容而不能一起工作的那些类可以一起工作

在iOS开发中，假设我们有两个不同作用的对象，子控件以及上层视图，我们如何将子控件中的操作通知给上层视图呢，或者以何种方式将上层视图想要的定制化内容传递到子控件中。在这个例子当中适配器模式提到的不能在一起工作的类就是子控件和上层视图，他们之间如果不以提供接口的方式来完成我说的任务的话，就可以使用适配器模式来进行操作。

上面的描述是不是让大家不自觉地想起了iOS开发中的`delegate`，在文章后面我会做一个标准化适配器与`delegate`的类比，你会发现`delegate`就是iOS中适配器的实现方式。

# UML
![对象适配器](image/DesignPattern/AdapterUML.png)
![类适配器](image/DesignPattern/AdapterClassUML.png)
## 成员
* 适配者：适配着是被适配的，这个类中的方法有客户希望有的适配方式
* 适配器：这个类是用来调用适配者中的接口的。也是适配器模式的核心类。
* 目标抽象类：这个类在适配器模式中通常的叫法是Target，他是声明调用者所使用的接口。

## 相互的关系
适配器模式有两种实现方式，分别是继承和对象两种方式，这两种模式在iOS中主要体现在适配者和适配器之间的关系。

在OC中是不支持多重继承，而适配器又必须知道客户要用的接口，所以适配器与目标抽象类的关系在OC中必须是实现协议的方式，来生声明适配器要用到的类。

讲到这里是不是还没有看明白这个跟`delegate`的关系，如果还不明白就继续往下看。

# Delegate
其实，iOS程序员应该很好理解适配器这个模式因为我们经常会使用到`delegate`，但是在我刚开始接触这个模式的时候一直转不过来的原因是，UML图中的`client`不是我们所理解的`我们`去掉用的方法，我就先来画一下我们常用的UITableView中的`delegate`的UML图。
